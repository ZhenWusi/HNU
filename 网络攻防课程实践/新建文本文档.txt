#include "MD5.h" 
#include <string.h>

void reduce(unsigned char * hv, unsigned char * item);
int equal(unsigned char * str1, unsigned char * str2, int len);

void CreateRainbow(unsigned char **rainbow) {
    for (int i = 0; i < 1000; i++) {
        // 分配动态内存给 item
        unsigned char *item = (unsigned char *)malloc(11);  // 修改为足够存储字符串的大小
        snprintf((char *)item, 11, "%010d", i);

        // 分配动态内存给 pwd
        unsigned char *pwd = (unsigned char *)malloc(16);
        // 使用 MD5 算法计算哈希值并存储在 pwd 中
        HashFunction(item, strlen((char *)item), pwd);

        // 在这里可以将密码添加到彩虹表中，这里只是一个示例，具体添加操作需要根据实际情况来实现
        rainbow[i] = (unsigned char *)malloc(16);  // 为每个密码分配内存
        memcpy(rainbow[i], pwd, 16);

        // 释放动态分配的内存
        free(item);
        free(pwd);
    }
}

// 彩虹表搜索
void SearchRainbow(unsigned char *pwd, unsigned char **rainbow) {
    for (int chain = 0; chain < 1000; chain++) {
        unsigned char password[10];
        snprintf((char *)password, 11, "%010d", chain);

        for (int i = 0; i < 10000; i++) {
            // 检查哈希值是否与目标匹配
            if (equal(rainbow[chain] + i * 16, pwd, 16)) {
                printf("找到密码：%s\n", password);
                return;
            }

            // 应用归约函数
            reduce(rainbow[chain] + i * 16, password);
        }
    }

    // 如果密码未找到
    printf("在彩虹表中未找到密码。\n");
}
int main(){
	int i = 0, j = 0;
	unsigned int t = 0;
	unsigned char hv[16] = {0};
	unsigned char rainbow[1000][20] = {0};
	unsigned char pwd[10] = {0};
	int linenum = 0;
	//计算flag
	unsigned char des[] = {0xbb, 0x0d, 0xd4, 0x91, 0x37, 0xb4, 0x08, 0x7b, 0x8e, 0xfc, 0xe1, 0x37, 0x2d, 0xe6, 0x35, 0xd1};
		
	//创建彩虹表
	CreateRainbow(rainbow); 
	printf("Rainbow is created\n");
	//搜索彩虹表
	SearchRainbow(pwd, rainbow);
	
	return 0;
}

void reduce(unsigned char * hv, unsigned char * item){
	int i = 0, count = 9;
	unsigned char low, high;
	for(i = 0; i < 10; i++){
		item[i] = '0';
	}
	for(i = 15; i > -1; i--){
		low = (hv[i] & 0xf);
		high = ((hv[i] >> 4) & 0xf);
		if(low < 10){
			item[count] += low;
			count--;
			if(count < 0){
				return;
			}
		}
		if(high < 10){
			item[count] += high;
			count--;
			if(count < 0){
				return;
			}
		}
	}
	for(i = 15; i > -1; i--){
		low = (hv[i] & 0xf);
		high = ((hv[i] >> 4) & 0xf);
		if(low > 9){
			item[count] += low - item[count + 1];
			count--;
			if(count < 0){
				return;
			}
		}
		if(high > 9){
			item[count] += high  - item[count + 1];
			count--;
			if(count < 0){
				return;
			}
		}
	}
}

int equal(unsigned char * str1, unsigned char * str2, int len){
	int i = 0;
	for(i = 0; i < len; i++){
		if(str1[i] != str2[i]){
			return 0;
		}
	}
	return 1;
}